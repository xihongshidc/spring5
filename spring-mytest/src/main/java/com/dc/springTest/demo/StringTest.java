package com.dc.springTest.demo;

import java.util.HashSet;

/**
 * Description:
 *  java 是一个跨平台的语言。 对于jvm虚拟机来说只需要遵循jvm字节码规范，任何编程语言都可以都可以编译生成字节码，然后由jvm解释执行。，
 * Author: duancong
 * Date: 2024/1/3 16:09
 */
public class StringTest {

	private final int num =2;
	private final static int num2 =2;
	private final static String num3 ="sdasdf";  //在准备阶段附上初始值.

	private static int a = 2; //在准备阶段附上

	public static void main(String[] args) {
		//idea 可以反编译class 文件  ,方便用户更直观的查看.
		//javap -v **.class > aaa.txt
//		String s = new String("addz") + new String("ddfz");
		//总共创建四个对象 两个String 对象， 一个Stringbuilder 对象，然后Stringbuilder.toString() 产生一个新对象
//		System.out.println(s);
//		System.out.println("asd");
		//操作码  操作数
		//class 类文件: 二进制流
		StringTest.method();

	}
	static {
		/**
		 *
		 * class 文件结构 : 魔数 ,副版本 ,主版本号  常量池, 访问标识Access flags ,类索引 父类索引, 接口集合,字段集合,方法集合（code 属性包含指令。code属性中还有属性，）, 属性表(源文件信息。)
		 *
		 * 常量池是class文件的重要信息 ,  属性表信息会引用常量池中的数据, 在java.exe 程序加载class文件之后会将其加载进内存, 然后常量池变成运行时常量池, 字符串也变成字符串常量池.
		 *
		 * 字段:访问权限,字段名索引, 字段描述(字段类型),
		 *
		 * 高版本 java 可以解释运行低版本的class 文件
		 *
		 * class 文件中不包含真正的直接引用。 类加载之后才会将这些符号引用替换为运行时常量池中的直接引用。。
		 * 常量池包含字面量和符号引用。 常量池：文本字符串，声明final 常量值。 符号引用：类的全限定名，方法的名称和描述符， //[Ljava/lang/String;
		 *
		 * 魔术 4个字节 副版本|主版本    常量池计数器(比常量个数多1 ，指针从1开始 ，目的是为了空出一个0代表不引用。。
		 * cafe babe    0000 0034(52)   003a(58)       0700 0201 0021
		 * 636f 6d2f 6463 2f73 7072 696e 6754 6573
		 * 742f 6465 6d6f 2f53 7472 696e 6754 6573
		 * 7407 0004 0100 106a 6176 612f 6c61 6e67
		 * 2f4f 626a 6563 7401 0006 3c69 6e69 743e
		 * 0100 0328 2956 0100 0443 6f64 650a 0003
		 * 0009 0c00 0500 0601 000f 4c69 6e65 4e75
		 * 6d62 6572 5461 626c 6501 0012 4c6f 6361
		 * 6c56 6172 6961 626c 6554 6162 6c65 0100
		 * 0474 6869 7301 0023 4c63 6f6d 2f64 632f
		 * 7370 7269 6e67 5465 7374 2f64 656d 6f2f
		 * 5374 7269 6e67 5465 7374 3b01 0004 6d61
		 * 696e 0100 1628 5b4c 6a61 7661 2f6c 616e
		 * 672f 5374 7269 6e67 3b29 5601 002e 6f72
		 * 672e 6173 7065 6374 6a2e 7765 6176 6572
		 * 2e4d 6574 686f 6444 6563 6c61 7261 7469
		 * 6f6e 4c69 6e65 4e75 6d62 6572 0700 1201
		 * 0017 6a61 7661 2f6c 616e 672f 5374 7269
		 * 6e67 4275 696c 6465 7207 0014 0100 106a
		 * 6176 612f 6c61 6e67 2f53 7472 696e 6708
		 * 0016 0100 0461 6464 7a0a 0013 0018 0c00
		 * 0500 1901 0015 284c 6a61 7661 2f6c 616e
		 * 672f 5374 7269 6e67 3b29 560a 0013 001b
		 * 0c00 1c00 1d01 0007 7661 6c75 654f 6601
		 * 0026 284c 6a61 7661 2f6c 616e 672f 4f62
		 * 6a65 6374 3b29 4c6a 6176 612f 6c61 6e67
		 * 2f53 7472 696e 673b 0a00 1100 1808 0020
		 * 0100 0464 6466 7a0a 0011 0022 0c00 2300
		 * 2401 0006 6170 7065 6e64 0100 2d28 4c6a
		 * 6176 612f 6c61 6e67 2f53 7472 696e 673b
		 * 294c 6a61 7661 2f6c 616e 672f 5374 7269
		 * 6e67 4275 696c 6465 723b 0a00 1100 260c
		 * 0027 0028 0100 0874 6f53 7472 696e 6701
		 * 0014 2829 4c6a 6176 612f 6c61 6e67 2f53
		 * 7472 696e 673b 0900 2a00 2c07 002b 0100
		 * 106a 6176 612f 6c61 6e67 2f53 7973 7465
		 * 6d0c 002d 002e 0100 036f 7574 0100 154c
		 * 6a61 7661 2f69 6f2f 5072 696e 7453 7472
		 * 6561 6d3b 0a00 3000 3207 0031 0100 136a
		 * 6176 612f 696f 2f50 7269 6e74 5374 7265
		 * 616d 0c00 3300 1901 0007 7072 696e 746c
		 * 6e01 0004 6172 6773 0100 135b 4c6a 6176
		 * 612f 6c61 6e67 2f53 7472 696e 673b 0100
		 * 0173 0100 124c 6a61 7661 2f6c 616e 672f
		 * 5374 7269 6e67 3b01 000a 536f 7572 6365
		 * 4669 6c65 0100 0f53 7472 696e 6754 6573
		 * 742e 6a61 7661 0021 0001 0003 0000 0000
		 * 0002 0001 0005 0006 0001 0007 0000 002f
		 * 0001 0001 0000 0005 2ab7 0008 b100 0000
		 * 0200 0a00 0000 0600 0100 0000 0800 0b00
		 * 0000 0c00 0100 0000 0500 0c00 0d00 0000
		 * 0900 0e00 0f00 0200 1000 0000 0800 0000
		 * 0900 0000 9300 0700 0000 6700 0500 0200
		 * 0000 2bbb 0011 59bb 0013 5912 15b7 0017
		 * b800 1ab7 001e bb00 1359 121f b700 17b6
		 * 0021 b600 254c b200 292b b600 2fb1 0000
		 * 0002 000a 0000 000e 0003 0000 000a 0023
		 * 000b 002a 000e 000b 0000 0016 0002 0000
		 * 002b 0034 0035 0000 0023 0008 0036 0037
		 * 0001 0001 0038 0000 0002 0039
		 */
	}
	/**
	 * description:
	 * 加载
	 * 生成模板数据,
	 * -----连接 : 验证 准备 和 解析
	 * 验证包含格式校验 : 魔术 校验 版本号校验, 数据的每一项对应的长度是否都相等.
	 *
	 * 语义检查:
	 * java 除了object以外所有的类都必须有一个父类存在.
	 * 类的方法是否重写,以及final 修饰的方法或者类不能被重写或者继承
	 * 在继承中,非抽象类是否实现了所有抽象方法或者接口方法
	 * 方法的兼容性. (比如方法除了返回值其他都一样,这对于虚拟机是没法识别的.)
	 *
	 * 字节码的校验:
	 * 在字节码执行过程中如果跳转到一个不可执行的指令.或者跳转到一条不存在的指令.
	 * 函数调用的是参数类型是否一致.
	 *
	 *
	 * 准备: 准备阶段是为非finla修饰的静态变量分配内存空间,为其分配默认值.
	 *         final static 修饰的 是静态常量 在准备阶段显示赋初始值.( 针对基本数据类型的字段来说, 如果代码中是显示的赋值 而不是通过对象的调用获取到值.)
	 *
	 *      如果使用字面量的方式定义一个字符串常量的话, 也是在准备环节直接显示赋值  , 对于引用类型 的 final static 是在初始化阶段赋初始值.
	 *
	 * 解析:  将符号引用替换为直接引用,也就是获得类,方法,字段 在内存中的指针或者偏移量  ,因此 存在直接引用可以肯定系统中存在该类或者该方法,或者该字段,
	 *
	 *
	 * -----初始化
	 *
	 *   static final 修饰 ,只要涉及到方法调用或者对象的使用都会在初始化阶段进行赋值初始值.
	 *  执行<clinit>() 静态代码块,并且为非final修饰静态变量赋值.或者final修饰的引用类型赋值.
	 *
	 *
	 *
	 *
	 *
	 */

	public static void method(){

		try {
			HashSet hashSet=new HashSet();
			HashSet hashSet1=new HashSet();
			boolean add = hashSet.add("1");
			boolean add2 = hashSet1.add("1");
			boolean add1 = hashSet.add("1");
			System.out.println(add);
			System.out.println(add1);
			System.out.println("1".hashCode());
			//方法区创建了一个模板数据。 并在堆空间创建一个class 对象，然后指向的是方法区中的数据。
			Class<?> aClass = Class.forName("java.lang.String");
			//基本数据类型由虚拟机预先定义好，引用数据类型则需要进行类的加载。
			int a = 21;
			String[] ar ={"","1"};
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
	}
}
